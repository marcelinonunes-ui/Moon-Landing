<!doctype html>
<html lang="pt">
<head>
  <meta charset="utf-8">
  <title>Moon Lander — Zoom Automático + Vários Pads + Modos + PWA</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, maximum-scale=1, user-scalable=no">
  <meta name="theme-color" content="#0a0f18">
  <link rel="manifest" href="manifest.webmanifest">
  <link rel="icon" href="icons/icon-192.png" sizes="192x192">
  <link rel="apple-touch-icon" href="apple-touch-icon.png">
  <style>
    :root { color-scheme: dark; }
    html,body {
      margin:0; height:100%; background:#0a0f18;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      -webkit-user-select: none; user-select: none;           /* evita seleção */
      -webkit-touch-callout: none;                            /* iOS long-press menu */
      touch-action: manipulation;                             /* melhora toques */
    }
    canvas { width:100vw; height:100vh; display:block; background:#060913; outline:none; }
    #btnReset{
      position:fixed; top:10px; right:10px; z-index:10;
      background:rgba(255,255,255,.08); color:#e7f0ff; border:1px solid rgba(255,255,255,.2);
      padding:8px 12px; border-radius:8px; cursor:pointer; backdrop-filter: blur(4px); user-select:none;
    }
    #btnReset:hover{ background:rgba(255,255,255,.16); }
    #soundTip{
      position:fixed; left:10px; top:10px; z-index:10;
      background:rgba(255,255,255,.08); color:#cfe0ff; border:1px solid rgba(255,255,255,.2);
      padding:6px 10px; border-radius:8px; user-select:none; font-size:12px;
      -webkit-user-select: none;
    }
  </style>
</head>
<body>
<canvas id="game" width="960" height="540" tabindex="0" aria-label="Moon Lander"></canvas>
<button id="btnReset">↺ Reiniciar</button>
<div id="soundTip">Som: <b id="sndState">OFF</b> — tecla <b>S</b></div>

<script>
/* Moon Lander — Terreno amplo + vários pads + modos Arcade/Realista + ZOOM automático
   Teclas: ←/→ rodar, ↑ motor, P pausa, R reiniciar, S som ON/OFF, M muda modo
*/
(function(){
"use strict";

/* ===== Canvas / DPI ===== */
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d', {alpha:false, desynchronized:true});
ctx.imageSmoothingEnabled = false;
let DPR = Math.max(1, Math.min(3, devicePixelRatio||1));
function resize(){
  DPR = Math.max(1, Math.min(3, devicePixelRatio||1));
  canvas.width  = Math.floor(innerWidth * DPR);
  canvas.height = Math.floor(innerHeight * DPR);
  ctx.setTransform(DPR,0,0,DPR,0,0);
}
addEventListener('resize', resize, {passive:true}); resize();
let W = canvas.width / DPR, H = canvas.height / DPR;
function dims(){ W = canvas.width / DPR; H = canvas.height / DPR; }

/* Foco / bloquear scroll setas / mobile gestures */
function ensureFocus(){ try{ canvas.focus({preventScroll:true}); }catch(_){} }
addEventListener('pointerdown', ensureFocus, {passive:true});
addEventListener('load', ensureFocus);
addEventListener('keydown', (e)=>{ if (['ArrowUp','ArrowDown','ArrowLeft','ArrowRight',' '].includes(e.key)) e.preventDefault(); }, {passive:false, capture:true});
canvas.addEventListener('touchstart', e => { if (e.touches.length > 1) e.preventDefault(); }, {passive:false});
canvas.addEventListener('gesturestart', e => e.preventDefault()); // iOS

/* ===== Utils ===== */
const TAU=Math.PI*2, DEG=Math.PI/180;
const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
const lerp=(a,b,t)=>a+(b-a)*t;
const rnd=(a,b)=>Math.random()*(b-a)+a;
function distPointToSeg(px,py,x1,y1,x2,y2){
  const vx=x2-x1,vy=y2-y1,wx=px-x1,wy=py-y1; const c1=vx*wx+vy*wy,c2=vx*vx+vy*vy;
  let t=c2>0?c1/c2:0; t=clamp(t,0,1); const cx=x1+t*vx, cy=y1+t*vy; return Math.hypot(px-cx,py-cy);
}

/* ===== Opções (guardadas) ===== */
const SAVE_KEY="moonlander_save_v6";
const OPT_KEY="moonlander_opts_v3";
function getSave(){ try{ return JSON.parse(localStorage.getItem(SAVE_KEY)||"{}"); }catch{ return {}; } }
function setSave(o){ localStorage.setItem(SAVE_KEY, JSON.stringify(o||{})); }
function bestLevel(){ return (getSave().best|0); }
function saveBest(n){ const s=getSave(); if ((n|0)>(s.best|0)){ s.best=n|0; setSave(s); } }
function getOpts(){ try{ return JSON.parse(localStorage.getItem(OPT_KEY)||"{}"); }catch{ return {}; } }
function setOpts(o){ localStorage.setItem(OPT_KEY, JSON.stringify(o||{})); }
const opts = Object.assign({mode:"Arcade", audio:false}, getOpts());

/* ===== Áudio (chiptune) ===== */
const sndLbl=document.getElementById('sndState');
const audio={
  ctx:null, master:null, musicGain:null, sfxGain:null, thrusterGain:null, thrusterNode:null,
  started:false, enabled: !!opts.audio, musicTimer:null, songRootHz:440,
  init(){
    if (this.started) return;
    this.ctx=new (window.AudioContext||window.webkitAudioContext)();
    this.master=this.ctx.createGain(); this.master.gain.value=this.enabled?0.7:0.0;
    this.musicGain=this.ctx.createGain(); this.musicGain.gain.value=0.28;
    this.sfxGain=this.ctx.createGain(); this.sfxGain.gain.value=0.6;
    this.thrusterGain=this.ctx.createGain(); this.thrusterGain.gain.value=0.0;
    this.musicGain.connect(this.master); this.sfxGain.connect(this.master); this.thrusterGain.connect(this.master);
    this.master.connect(this.ctx.destination);
    // thruster: noise + LPF
    const buf=this.ctx.createBuffer(1,this.ctx.sampleRate*2,this.ctx.sampleRate);
    const d=buf.getChannelData(0); for(let i=0;i<d.length;i++) d[i]=Math.random()*2-1;
    const src=this.ctx.createBufferSource(); src.buffer=buf; src.loop=true;
    const lpf=this.ctx.createBiquadFilter(); lpf.type='lowpass'; lpf.frequency.value=900;
    src.connect(lpf); lpf.connect(this.thrusterGain); src.start(); this.thrusterNode={src,lpf};
    this.started=true; this.enabled?this.musicStart():this.musicStop(); sndLbl.textContent=this.enabled?'ON':'OFF';
  },
  setEnabled(on){ this.enabled=on; sndLbl.textContent=on?'ON':'OFF'; setOpts(Object.assign(opts,{audio:on})); if (!this.started) return; this.master.gain.value=on?0.7:0.0; on?this.musicStart():this.musicStop(); if (!on) this.thruster(false); },
  thruster(on){ if (!this.started||!this.enabled) return; const t=this.ctx.currentTime; this.thrusterGain.gain.cancelScheduledValues(t); this.thrusterGain.gain.linearRampToValueAtTime(on?0.45:0.0,t+0.06); },
  beep(f=740,dur=0.12,type='square',gain=0.35){ if (!this.started||!this.enabled) return; const o=this.ctx.createOscillator(); o.type=type; o.frequency.value=f; const g=this.ctx.createGain(); g.gain.value=gain; o.connect(g); g.connect(this.sfxGain); o.start(); g.gain.exponentialRampToValueAtTime(0.001,this.ctx.currentTime+dur); o.stop(this.ctx.currentTime+dur+0.02); },
  boom(){ if (!this.started||!this.enabled) return; const n=this.ctx.createBufferSource(); const b=this.ctx.createBuffer(1,this.ctx.sampleRate*0.4|0,this.ctx.sampleRate); const d=b.getChannelData(0); for(let i=0;i<d.length;i++) d[i]=(Math.random()*2-1)*(1-i/d.length); n.buffer=b; const g=this.ctx.createGain(); g.gain.value=0.7; n.connect(g); g.connect(this.sfxGain); n.start(); n.stop(this.ctx.currentTime+0.41);
    const o=this.ctx.createOscillator(); o.type='square'; o.frequency.setValueAtTime(220,this.ctx.currentTime); o.frequency.exponentialRampToValueAtTime(70,this.ctx.currentTime+0.4);
    const og=this.ctx.createGain(); og.gain.value=0.5; o.connect(og); og.connect(this.sfxGain); o.start(); o.stop(this.ctx.currentTime+0.41); },
  musicStart(){
    if (!this.started||!this.enabled) return;
    this.musicStop();
    const scale=[0,2,3,5,7,9,10];
    let step=0; const tempo=108; const beatMs=60000/tempo; const ctx=this.ctx; const root=this.songRootHz;
    const tick=()=>{
      const bass = (opts.mode==='Realista' ? 0.14 : 0.18);
      const bassNote = 55 * Math.pow(2, (scale[(step>>1)%scale.length])/12);
      const oB=ctx.createOscillator(); oB.type='triangle'; oB.frequency.value=bassNote; const gB=ctx.createGain(); gB.gain.value=bass; oB.connect(gB); gB.connect(this.musicGain); oB.start(); gB.gain.exponentialRampToValueAtTime(0.0001,ctx.currentTime+0.28); oB.stop(ctx.currentTime+0.3);
      const arp=[0,7,12,16]; const idx=(step%8<4)?step%4:7-(step%8); const f = root * Math.pow(2,(arp[idx] + scale[(step)%scale.length])/12);
      const oL=ctx.createOscillator(); oL.type='square'; oL.frequency.value=f; const gL=ctx.createGain(); gL.gain.value=0.16; const fL=ctx.createBiquadFilter(); fL.type='lowpass'; fL.frequency.value=2400; oL.connect(fL); fL.connect(gL); gL.connect(this.musicGain); oL.start(); gL.gain.exponentialRampToValueAtTime(0.0001,ctx.currentTime+0.26); oL.stop(ctx.currentTime+0.28);
      if (step%4===0){ const oP=ctx.createOscillator(); oP.type='sawtooth'; oP.frequency.value=root/2 * Math.pow(2, scale[step%scale.length]/12); const gP=ctx.createGain(); gP.gain.value=0.06; oP.connect(gP); gP.connect(this.musicGain); oP.start(); gP.gain.exponentialRampToValueAtTime(0.0001,ctx.currentTime+0.55); oP.stop(ctx.currentTime+0.6); }
      step=(step+1)%64;
    };
    this.musicTimer=setInterval(tick, beatMs*0.5);
  },
  musicStop(){ if (this.musicTimer){ clearInterval(this.musicTimer); this.musicTimer=null; } }
};
if (opts.audio){ sndLbl.textContent='ON'; }
function toggleSound(){ if (!audio.started) audio.init(); audio.setEnabled(!audio.enabled); }
document.getElementById('soundTip').addEventListener('click', toggleSound);

/* ===== Partículas ===== */
const particles=[];
function addParticle(x,y,vx,vy,life,size,color,grav=0){ particles.push({x,y,vx,vy,life,age:0,size,color,grav}); }
function updateParticles(dt){ for(let i=particles.length-1;i>=0;i--){ const p=particles[i]; p.age+=dt; if(p.age>=p.life){ particles.splice(i,1); continue; } p.vy+=p.grav*dt; p.x+=p.vx*dt; p.y+=p.vy*dt; } }
function drawParticles(){ for(const p of particles){ const t=1-p.age/p.life; ctx.globalAlpha=clamp(t,0,1); ctx.fillStyle=p.color; ctx.beginPath(); ctx.arc(p.x, p.y, Math.max(0.2,p.size*t), 0, TAU); ctx.fill(); } ctx.globalAlpha=1; }

/* ===== Mundo / Terreno ===== */
let terrain=[]; // [{x,y}] coords do mundo
let pads=[];    // [{x,w,top,safeSpeed,safeAngle,label,color}]
const PAD_H=8, GROUND_MARGIN=28;
let worldW=2000;
function midpointTerrain(n, baselineY, amp, span){
  const pts=new Array(n).fill(0).map((_,i)=>({x: i*(span/(n-1)), y: baselineY}));
  function displace(a,b,disp){ if (b<=a+1) return; const m=(a+b)>>1, ya=pts[a].y, yb=pts[b].y; pts[m].y=(ya+yb)/2 + rnd(-disp,disp); displace(a,m,disp*0.55); displace(m,b,disp*0.55); }
  pts[0].y=baselineY+rnd(-amp*0.3,amp*0.3); pts[n-1].y=baselineY+rnd(-amp*0.3,amp*0.3);
  displace(0,n-1,amp);
  for(let k=0;k<2;k++) for(let i=1;i<n-1;i++) pts[i].y=(pts[i-1].y+pts[i].y+pts[i+1].y)/3;
  for(const p of pts) p.y=clamp(p.y, H*0.35, H-GROUND_MARGIN);
  return pts;
}
function carvePadRange(pts, x, padW){
  let i0=0; while(i0<pts.length-1 && pts[i0+1].x<x) i0++;
  let i1=i0; const x2=x+padW; while(i1<pts.length-1 && pts[i1].x<x2) i1++;
  let sum=0,cnt=0; for(let i=i0;i<=i1;i++){ sum+=pts[i].y; cnt++; }
  const y=(sum/cnt)|0; for(let i=i0;i<=i1;i++) pts[i].y=y;
  return {x, w: pts[i1].x-pts[i0].x, y:y-PAD_H};
}
function buildWorld(level){
  worldW = Math.max(W*3, 2200 + level.idx*40);
  const baseline=H*0.78, amp=100;
  terrain = midpointTerrain( Math.max(28, Math.floor(worldW/80)), baseline, amp, worldW );
  pads.length=0;
  const padCount = 3 + (level.idx>10?1:0);
  const slots = []; for(let i=0;i<padCount;i++) slots.push( lerp(0.12,0.88, i/(padCount-1)) );
  for(const s of slots){
    const cx=s*worldW, t=Math.random();
    const diff=(t<0.45)?'Fácil':(t<0.8?'Médio':'Difícil');
    const wBase = diff==='Fácil' ? lerp(220,180, level.t) : diff==='Médio' ? lerp(160,120, level.t) : lerp(110,70, level.t);
    const padW=Math.round(wBase);
    const pr=carvePadRange(terrain, clamp(cx - padW/2, 40, worldW-40-padW), padW);
    const safeSpeed=Math.round((diff==='Fácil'?95:diff==='Médio'?70:45) - level.t*15);
    const safeAngle=Math.round((diff==='Fácil'?18:diff==='Médio'?12:8) - level.t*3);
    const color = diff==='Fácil' ? "#3be0a0" : diff==='Médio' ? "#ffd95a" : "#ff9b5a";
    pads.push({ x:pr.x, w:pr.w, top:pr.y, safeSpeed, safeAngle, label:diff, color });
  }
}

/* ===== Meteoritos ===== */
const meteorites=[];
function spawnMeteor(L){
  const r=rnd(6,16), x=rnd(-60, worldW+60), y=-40, vx=rnd(-30,30), vy=rnd(L.meteorMinVy,L.meteorMaxVy), spin=rnd(-2,2);
  meteorites.push({x,y,vx,vy,r,spin,ang:0,alive:true});
}
let meteorTimer=0;
function updateMeteorites(dt,L){
  meteorTimer-=dt;
  if (meteorTimer<=0){ spawnMeteor(L); meteorTimer=rnd(L.meteorRate*0.6, L.meteorRate*1.4); }
  for (let i=meteorites.length-1;i>=0;i--){
    const m=meteorites[i]; if(!m.alive){ meteorites.splice(i,1); continue; }
    m.ang+=m.spin*dt; m.vy+=L.gravity*0.7*dt; m.x+=m.vx*dt; m.y+=m.vy*dt;
    if (Math.hypot(m.x-ship.x, m.y-ship.y) < m.r + SHIP_R*0.9){ explodeAt(m.x,m.y); crash(); m.alive=false; continue; }
    for(let j=0;j<terrain.length-1;j++){ const a=terrain[j], b=terrain[j+1];
      if (distPointToSeg(m.x,m.y, a.x,a.y, b.x,b.y) <= m.r){
        for(let k=0;k<14;k++){ const ang=rnd(0,TAU), sp=rnd(30,120);
          addParticle(m.x,m.y, Math.cos(ang)*sp, Math.sin(ang)*sp*0.5, rnd(0.3,0.7), rnd(1.2,2.6), "#cbbba0", 120);
        } m.alive=false; break;
      }
    }
    if (m.y>H+80) m.alive=false;
  }
}
function drawMeteorites(){ for(const m of meteorites){ ctx.save(); ctx.translate(m.x, m.y); ctx.rotate(m.ang);
  ctx.fillStyle="#8a7f7a"; ctx.strokeStyle="#5c5350"; ctx.lineWidth=1;
  ctx.beginPath(); for(let i=0;i<7;i++){ const a=i/7*TAU, rr=m.r*(0.9+0.2*Math.sin(i*1.7)); const px=Math.cos(a)*rr, py=Math.sin(a)*rr; if(i===0)ctx.moveTo(px,py); else ctx.lineTo(px,py); }
  ctx.closePath(); ctx.fill(); ctx.stroke(); ctx.restore(); } }

/* ===== Nave / Física ===== */
const SHIP_R=14;
const ROT_SPEED=120*DEG;
const BASE_THRUST=185;
const FUEL_BURN=12;

const ship={ x:0,y:0,vx:0,vy:0,ang:0,angVel:0,left:false,right:false,thrust:false,fuel:100, alive:true };

/* ===== CÂMARA com ZOOM (cinemático) ===== */
const cam = {
  x:0, y:0, vx:0, vy:0,   // velocidades da câmara (mola vertical)
  scale:1, targetScale:1,
  min:0.65, max:1.5,
  apply(){ ctx.save(); ctx.scale(this.scale, this.scale); ctx.translate(-this.x, -this.y); },
  restore(){ ctx.restore(); }
};

// ---- computeCamera cinemático ----
function computeCamera(dt){
  cam.min = 0.70;
  cam.max = 1.60;

  // pad mais próximo (métrica normalizada)
  let nearest=null, bestD=Infinity;
  for (const p of pads){
    const cx = p.x + p.w/2, cy = p.top;
    const nx = (ship.x - cx) / Math.max(80, p.w*0.6);
    const ny = (ship.y - (cy - 20)) / 120;
    const d  = Math.hypot(nx, ny*0.8);
    if (d < bestD){ bestD=d; nearest=p; }
  }
  // histerese perto/longe
  if (cam._near === undefined) cam._near = false;
  const NEAR_ENTER=0.90, NEAR_EXIT=1.20;
  if (nearest){
    if (!cam._near && bestD < NEAR_ENTER) cam._near = true;
    if ( cam._near && bestD > NEAR_EXIT ) cam._near = false;
  } else cam._near = false;

  // base do zoom + contexto
  const baseNear=1.40, baseFar=0.80;
  let targetScale = cam._near ? baseNear : baseFar;

  const altNorm = clamp((H - ship.y) / H, 0, 1);
  targetScale *= (1 - altNorm*0.15);                 // altitude
  const TWO_PI=Math.PI*2;
  const a = Math.abs((ship.ang % TWO_PI + TWO_PI) % TWO_PI);
  const uprightDeg = Math.min(a, Math.abs(TWO_PI - a))*(180/Math.PI);
  const tiltOut = clamp((uprightDeg - 6) / 40, 0, 1);
  targetScale *= (1 - tiltOut*0.12);                 // inclinação
  const speed = Math.hypot(ship.vx, ship.vy);
  const speedOut = clamp((speed - 120)/220, 0, 0.15);
  targetScale *= (1 - speedOut);                     // velocidade

  targetScale = clamp(targetScale, cam.min, cam.max);
  cam.targetScale = targetScale;
  const SCALE_LERP=0.025;
  cam.scale = lerp(cam.scale, cam.targetScale, SCALE_LERP);

  // look-ahead dinâmico (↑ com velocidade e nível)
  const difficultyBoost = currentLevel ? clamp((currentLevel.idx-1)/19, 0, 1) : 0;
  const laFactor = 0.20 + clamp((speed-90)/180, 0, 0.35) + difficultyBoost*0.10;
  const laCap    = 180 + (currentLevel ? currentLevel.idx*8 : 0);
  const lookAheadX = clamp(ship.vx * laFactor, -laCap, laCap);

  const vW = W / cam.scale, vH = H / cam.scale;
  const targetX = clamp(ship.x + lookAheadX - vW*0.5, 0, Math.max(0, worldW - vW));
  const rawTargetY = ship.y - vH*0.45;
  const targetY = clamp(rawTargetY, 0, Math.max(0, H - vH));

  // follow vertical por mola (crítico)
  const omega=5.0, zeta=1.0;
  const ay = omega*omega*(targetY - cam.y) - 2*zeta*omega*cam.vy;
  cam.vy += ay*dt;
  cam.y  += cam.vy*dt;

  // horizontal por lerp suave
  const PAN_LERP_X=0.06;
  if (isNaN(cam.x)) cam.x = targetX;
  cam.x = lerp(cam.x, targetX, PAN_LERP_X);

  // clamp final
  cam.x = clamp(cam.x, 0, Math.max(0, worldW - vW));
  cam.y = clamp(cam.y, 0, Math.max(0, H - vH));
}

/* ===== Estados / Níveis ===== */
const STATES={ MENU:0, PLAY:1, CRASH:2, LAND:3, PAUSE:4, OVER:5, LEVELSEL:6 };
let state=STATES.MENU;

const LEVELS_TOTAL=20;
let levels=[], cur=0, currentLevel=null;
function makeLevel(i){
  const t=i/(LEVELS_TOTAL-1);
  const roots=[392,440,523.25,349.23]; // G4, A4, C5, F4
  return {
    idx:i+1, name:`Nível ${i+1}`, t,
    gravity: lerp(85, 160, t),
    windMax: lerp(0, 70, t),
    padCount: 3 + (i>10?1:0),
    fuel: Math.round(lerp(115, 55, t)),
    baseSpeed: Math.round(lerp(85, 45, t)),
    baseAngle: Math.round(lerp(18, 8, t)),
    windPeriod: 6 + 6*t,
    meteorRate: lerp(2.2, 1.2, t),
    meteorMinVy: lerp(60, 90, t),
    meteorMaxVy: lerp(120, 170, t),
    musicRoot: roots[i%roots.length]
  };
}
function generateLevels(){ levels.length=0; for(let i=0;i<LEVELS_TOTAL;i++) levels.push(makeLevel(i)); }

/* ===== Modos (Arcade/Realista) ===== */
function applyModeToLevel(L, mode){
  const M = Object.assign({}, L);
  if (mode==='Realista'){
    M.gravity *= 1.1;
    M.fuel = Math.round(M.fuel*0.8);
    M.baseSpeed = Math.max(28, Math.round(M.baseSpeed*0.85));
    M.baseAngle = Math.max(6,  Math.round(M.baseAngle*0.8));
    M.meteorRate *= 0.9;
  }
  return M;
}

/* ===== Fluxo ===== */
function startGame(startLevel=0){
  generateLevels();
  cur=clamp(startLevel,0,levels.length-1);
  loadLevel(cur);
  state=STATES.PLAY;
}
function loadLevel(i){
  dims();
  currentLevel = applyModeToLevel(levels[i], opts.mode);
  audio.songRootHz = currentLevel.musicRoot;
  if (audio.started && audio.enabled){ audio.musicStart(); }
  ship.x = W*0.5; ship.y = Math.max(80, H*0.18);
  ship.vx=ship.vy=0; ship.ang=0; ship.angVel=0; ship.fuel=currentLevel.fuel; ship.alive=true;
  time=0; wind=0; meteorites.length=0; meteorTimer=0; particles.length=0;
  buildWorld(currentLevel);
  cam.x = clamp(ship.x - (W/cam.scale)*0.5, 0, Math.max(0, worldW - W/cam.scale));
  cam.y = clamp(ship.y - (H/cam.scale)*0.45, 0, Math.max(0, H - H/cam.scale));
}

/* ===== Controlo ===== */
document.getElementById('btnReset').addEventListener('click', ()=>{ if (state===STATES.MENU) { startFromMenuDefault(); } else { restartLevel(); } });
function restartLevel(){ if (!currentLevel) return startGame(0); loadLevel(cur); state=STATES.PLAY; }

addEventListener('keydown', (e)=>{
  if (e.repeat) return;
  if (state===STATES.MENU || state===STATES.LEVELSEL){
    if (e.key===' '||e.key==='Enter'||e.key==='ArrowUp'){ startFromMenuDefault(); }
    if (e.key.toLowerCase()==='m'){ toggleMode(); drawMenu(); }
    if (e.key.toLowerCase()==='s'){ toggleSound(); }
    return;
  }
  if (e.key==='ArrowUp'){ ship.thrust=true; if(audio.enabled) audio.thruster(true); }
  if (e.key==='ArrowLeft'){ ship.left=true; rcsBurst(-1); }
  if (e.key==='ArrowRight'){ ship.right=true; rcsBurst(1); }
  if (e.key.toLowerCase()==='p'){ state=(state===STATES.PLAY)?STATES.PAUSE:STATES.PLAY; }
  if (e.key.toLowerCase()==='r'){ restartLevel(); }
  if (e.key.toLowerCase()==='s'){ toggleSound(); }
  if (e.key.toLowerCase()==='m'){ toggleMode(); }
});
addEventListener('keyup', (e)=>{
  if (e.key==='ArrowUp'){ ship.thrust=false; audio.thruster(false); }
  if (e.key==='ArrowLeft') ship.left=false;
  if (e.key==='ArrowRight') ship.right=false;
});
function toggleMode(){ opts.mode = (opts.mode==='Arcade'?'Realista':'Arcade'); setOpts(opts); if (state!==STATES.MENU){ loadLevel(cur); } }

/* Toque */
const touch={left:false,right:false,thrust:false};
let pointers=new Map();
canvas.addEventListener('pointerdown',(e)=>{ canvas.setPointerCapture(e.pointerId); pointers.set(e.pointerId,{x:e.clientX,y:e.clientY}); handleTouch(e.clientX,e.clientY,true); });
canvas.addEventListener('pointermove',(e)=>{ if(!pointers.has(e.pointerId)) return; pointers.set(e.pointerId,{x:e.clientX,y:e.clientY}); });
function endPointer(e){ pointers.delete(e.pointerId); touch.left=touch.right=touch.thrust=false; for(const p of pointers.values()) handleTouch(p.x,p.y,true); syncTouch(); }
canvas.addEventListener('pointerup', endPointer); canvas.addEventListener('pointercancel', endPointer); canvas.addEventListener('lostpointercapture', endPointer);
function btnGeom(){ const pad=18; const R=Math.max(44, Math.min(68, Math.floor(Math.min(innerWidth,innerHeight)*0.07)));
  return { left:{x:pad+R,y:innerHeight-pad-R,r:R}, right:{x:pad+R*3+16,y:innerHeight-pad-R,r:R}, thrust:{x:innerWidth-pad-R,y:innerHeight-pad-R,r:Math.floor(R*1.1)} };
}
function insideCircle(px,py,c){ const dx=px-c.x, dy=py-c.y; return dx*dx+dy*dy<=c.r*c.r; }
function handleTouch(x,y){ const g=btnGeom(); if(insideCircle(x,y,g.left))touch.left=true; if(insideCircle(x,y,g.right))touch.right=true; if(insideCircle(x,y,g.thrust))touch.thrust=true; syncTouch(); }
function syncTouch(){ ship.left=touch.left; ship.right=touch.right; ship.thrust=touch.thrust; if(audio.enabled) audio.thruster(touch.thrust); }

/* RCS */
function rcsBurst(dir){ for(let k=0;k<6;k++){ const a=ship.ang + (dir<0?Math.PI/2:-Math.PI/2)+rnd(-0.25,0.25); const sp=rnd(60,120);
  addParticle(ship.x+Math.cos(a+Math.PI)*8, ship.y+Math.sin(a+Math.PI)*8, Math.cos(a)*sp+ship.vx*0.1, Math.sin(a)*sp+ship.vy*0.1, rnd(0.2,0.4), rnd(0.8,1.6), "#9ad7ff");
}}

/* ===== Loop ===== */
const MAX_DT=1/20; let last=performance.now();
function tick(now){ requestAnimationFrame(tick); const dt=Math.min(MAX_DT,(now-last)/1000); last=now; dims(); if(state===STATES.PLAY) update(dt); render(); }
requestAnimationFrame(tick);
let time=0, wind=0;

function update(dt){
  time+=dt;
  const L=currentLevel;
  const windTarget=Math.sin(time*(TAU/L.windPeriod))*L.windMax; wind=lerp(wind, windTarget, 0.03);

  if (opts.mode==='Arcade'){ if (ship.left) ship.ang -= ROT_SPEED*dt; if (ship.right) ship.ang += ROT_SPEED*dt; }
  else { const torque=(ship.right?1:0)-(ship.left?1:0); ship.angVel += torque*2.8*DEG; ship.angVel*=0.985; ship.ang+=ship.angVel; }

  let thrustAcc=0;
  if (ship.thrust && ship.fuel>0){
    const thrustMult=(opts.mode==='Realista')?0.92:1.0;
    thrustAcc=BASE_THRUST*thrustMult;
    const burn=FUEL_BURN*(opts.mode==='Realista'?1.15:1.0);
    ship.fuel=Math.max(0, ship.fuel - burn*dt);
    for(let k=0;k<3;k++){
      const a=ship.ang+Math.PI+rnd(-0.18,0.18); const sp=rnd(70,140);
      addParticle(ship.x + Math.sin(ship.ang)*10, ship.y - Math.cos(ship.ang)*10,
        Math.sin(a)*sp + ship.vx*0.1, -Math.cos(a)*sp + ship.vy*0.1, rnd(0.25,0.45), rnd(1.2,2.2), "#ffbb55");
    }
  }

  const ax=Math.sin(ship.ang)*thrustAcc + wind/1.0;
  const ay=-Math.cos(ship.ang)*thrustAcc + L.gravity;
  ship.vx+=ax*dt; ship.vy+=ay*dt;
  ship.x+=ship.vx*dt; ship.y+=ship.vy*dt;

  // limites horizontais do mundo
  if (ship.x<0){ ship.x=0; ship.vx=0; }
  if (ship.x>worldW){ ship.x=worldW; ship.vx=0; }

  // câmara/zoom
  computeCamera(dt);

  // aterragem (pads)
  if (ship.vy>0){
    for (const p of pads){
      if ((ship.y + SHIP_R) >= p.top && (ship.y + SHIP_R) <= p.top + PAD_H + 6 &&
          ship.x >= p.x && ship.x <= p.x + p.w){
        const speed=Math.hypot(ship.vx, ship.vy);
        const angleErr=Math.abs((ship.ang%TAU+TAU)%TAU);
        const upright=Math.min(angleErr, Math.abs(TAU-angleErr))*(180/Math.PI);
        if (speed <= p.safeSpeed && upright <= p.safeAngle){
          land(p);
          for(let k=0;k<16;k++){ const a=rnd(-Math.PI,0), sp=rnd(20,80); addParticle(ship.x+rnd(-10,10), p.top+PAD_H, Math.cos(a)*sp, Math.sin(a)*sp*0.4, rnd(0.3,0.7), rnd(1.5,3), "#cbbba0", 120); }
          return;
        } else { crash(); return; }
      }
    }
  }

  // colisão terreno
  for(let i=0;i<terrain.length-1;i++){
    const a=terrain[i], b=terrain[i+1];
    if (distPointToSeg(ship.x, ship.y, a.x,a.y, b.x,b.y) <= SHIP_R){ crash(); return; }
  }

  updateMeteorites(dt, L);

  ship.vx=clamp(ship.vx,-1000,1000); ship.vy=clamp(ship.vy,-1000,1000);

  updateParticles(dt);
}

function explodeAt(x,y){ for(let k=0;k<36;k++){ const a=rnd(0,TAU), sp=rnd(60,240); addParticle(x,y, Math.cos(a)*sp, Math.sin(a)*sp, rnd(0.4,0.9), rnd(1.5,3.5), "#ff8844", 60); } }
function crash(){ if(state!==STATES.PLAY) return; state=STATES.CRASH; ship.thrust=false; audio.thruster(false); audio.boom(); explodeAt(ship.x,ship.y); }
function land(padHit){
  state=STATES.LAND; ship.thrust=false; ship.vx=ship.vy=0; audio.thruster(false);
  const seq = padHit.label==='Fácil' ? [660,784,880] : padHit.label==='Médio' ? [784,880,988] : [880,988,1175];
  let delay=0; for(const f of seq){ setTimeout(()=>audio.beep(f,0.11,'square',0.35), delay); delay+=120; }
  saveBest(cur+1);
  lastLandedPad = padHit;
}
let lastLandedPad=null;

/* ===== Render ===== */
function drawSpaceBg(){ const g=ctx.createLinearGradient(0,0,0,H); g.addColorStop(0,"#060913"); g.addColorStop(1,"#0b0f1a"); ctx.fillStyle=g; ctx.fillRect(0,0,W,H);
  const seed=4321; let s=seed; const R=()=> (s=(s*9301+49297)%233280)/233280; ctx.globalAlpha=0.7; ctx.fillStyle="#bcd3ff";
  for(let i=0;i<60;i++){ ctx.fillRect(R()*W, 40+R()*H*0.35, 1,1); } ctx.globalAlpha=1; }
function roundRect(x,y,w,h,r){ const rr=Math.min(r,Math.abs(w)/2,Math.abs(h)/2); ctx.beginPath(); ctx.moveTo(x+rr,y); ctx.arcTo(x+w,y, x+w,y+h, rr); ctx.arcTo(x+w,y+h,x,y+h,rr); ctx.arcTo(x,y+h,x,y,rr); ctx.arcTo(x,y,x+w,y,rr); ctx.closePath(); }

function withCamera(drawFn){
  cam.apply();
  drawFn();
  cam.restore();
}

function drawTerrain(){
  ctx.fillStyle="#1e2433"; ctx.beginPath(); ctx.moveTo(0,H);
  for(const p of terrain) ctx.lineTo(p.x, p.y);
  ctx.lineTo(worldW, H); ctx.closePath(); ctx.fill();
  ctx.strokeStyle="rgba(255,255,255,0.06)"; ctx.lineWidth=2;
  for(let i=0;i<terrain.length-1;i++){ const a=terrain[i], b=terrain[i+1]; ctx.beginPath(); ctx.moveTo(a.x,a.y); ctx.lineTo(b.x,b.y); ctx.stroke(); }
  for(const p of pads){
    ctx.globalAlpha=0.30; ctx.fillStyle="#000"; roundRect(p.x-6, p.top+PAD_H, p.w+12, 10, 4); ctx.fill(); ctx.globalAlpha=1;
    ctx.fillStyle = (state===STATES.LAND && lastLandedPad===p) ? "#00d78f" : p.color;
    roundRect(p.x, p.top, p.w, PAD_H, 3); ctx.fill();
    ctx.fillStyle="#8892a8"; ctx.fillRect(p.x-6, p.top, 4, PAD_H+10); ctx.fillRect(p.x+p.w+2, p.top, 4, PAD_H+10);
    const t=(Math.sin(time*6)+1)/2; ctx.globalAlpha=0.25+0.35*t; ctx.fillStyle="#8fe3ff"; roundRect(p.x, p.top-6, p.w, 4, 2); ctx.fill(); ctx.globalAlpha=1;
    ctx.fillStyle="#cfe0ff"; ctx.font="12px system-ui"; ctx.textAlign="center";
    ctx.fillText(`${p.label} — Vel ≤ ${p.safeSpeed} | Âng ≤ ${p.safeAngle}°`, p.x+p.w/2, p.top-10);
  }
}

function drawMeteoritesCam(){ drawMeteorites(); }

function drawShip(){
  ctx.save(); ctx.translate(ship.x, ship.y); ctx.rotate(ship.ang);
  const s=1.0, t=time;
  ctx.save(); ctx.globalAlpha=0.18; ctx.fillStyle="#000"; ctx.beginPath(); ctx.ellipse(0,16*s,14*s,4*s,0,0,TAU); ctx.fill(); ctx.restore();
  if (ship.thrust && state===STATES.PLAY && ship.fuel>0){
    const len=18+Math.sin(t*50)*4;
    ctx.globalAlpha=0.25; ctx.fillStyle="#ffb84d"; ctx.beginPath(); ctx.ellipse(0, 10+len*0.6, 7, len*0.8, 0,0,TAU); ctx.fill(); ctx.globalAlpha=1;
    ctx.beginPath(); ctx.moveTo(0,10); ctx.lineTo(-6,10+len); ctx.lineTo(6,10+len); ctx.closePath(); ctx.fillStyle="#ff9a1f"; ctx.fill();
    ctx.globalAlpha=0.75; ctx.fillStyle="#ffd76a"; ctx.beginPath(); ctx.moveTo(0,10); ctx.lineTo(-3,10+len*0.65); ctx.lineTo(3,10+len*0.65); ctx.closePath(); ctx.fill(); ctx.globalAlpha=1;
  }
  let gBell=ctx.createLinearGradient(0,8,0,18); gBell.addColorStop(0,"#9aa6bf"); gBell.addColorStop(1,"#5f6b86");
  ctx.fillStyle=gBell; ctx.beginPath(); ctx.moveTo(-8*s,10*s); ctx.lineTo(-6*s,18*s); ctx.lineTo(6*s,18*s); ctx.lineTo(8*s,10*s); ctx.closePath(); ctx.fill();
  const spring=Math.sin(t*6)*0.6; ctx.lineWidth=2; ctx.strokeStyle="#c2cce0";
  ctx.beginPath(); ctx.moveTo(-8*s,9*s); ctx.lineTo(-14*s,(14+spring)*s); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(8*s,9*s);  ctx.lineTo(14*s,(14+spring)*s); ctx.stroke();
  ctx.lineWidth=2.2; ctx.beginPath(); ctx.moveTo(-16*s,(14+spring)*s); ctx.lineTo(-10*s,(14+spring)*s); ctx.moveTo(10*s,(14+spring)*s); ctx.lineTo(16*s,(14+spring)*s); ctx.stroke();
  let gHull=ctx.createLinearGradient(-10,-16,12,12); gHull.addColorStop(0,"#e9f3ff"); gHull.addColorStop(0.55,"#cfdcf5"); gHull.addColorStop(1,"#a7b7d8");
  ctx.fillStyle=gHull; ctx.strokeStyle="#7e8eae"; ctx.lineWidth=1.6;
  ctx.beginPath(); ctx.moveTo(0,-16*s); ctx.lineTo(11*s,10*s); ctx.lineTo(-11*s,10*s); ctx.closePath(); ctx.fill(); ctx.stroke();
  let gDome=ctx.createRadialGradient(-3,-8,1,0,-8,8); gDome.addColorStop(0,"#b7ecff"); gDome.addColorStop(1,"#6fb9d6");
  ctx.fillStyle=gDome; ctx.beginPath(); ctx.arc(0,-8*s,5.2*s,0,TAU); ctx.fill();
  ctx.globalAlpha=0.35; ctx.fillStyle="#fff"; ctx.beginPath(); ctx.ellipse(-2.5*s,-10*s,2.2*s,1.1*s,-0.6,0,TAU); ctx.fill(); ctx.globalAlpha=1;
  ctx.strokeStyle="#9fb3d6"; ctx.lineWidth=1.5; ctx.beginPath(); ctx.moveTo(0,-16*s); ctx.lineTo(0,-20*s); ctx.stroke();
  ctx.fillStyle="#ff4d6d"; ctx.beginPath(); ctx.arc(0,-22*s,1.6*s,0,TAU); ctx.fill();
  ctx.fillStyle="#44ff99"; ctx.beginPath(); ctx.arc(-7*s,2*s,1.6*s,0,TAU); ctx.fill();
  ctx.fillStyle="#ffaa33"; ctx.beginPath(); ctx.arc(7*s,2*s,1.6*s,0,TAU); ctx.fill();
  ctx.restore();
}

function drawHUD(){
  const speed=Math.hypot(ship.vx,ship.vy);
  const angleErr=Math.abs((ship.ang%TAU+TAU)%TAU);
  const upright=Math.min(angleErr, Math.abs(TAU-angleErr))*(180/Math.PI);
  ctx.globalAlpha=0.85; ctx.fillStyle="rgba(6,9,19,0.55)"; roundRect(12,12,430,118,10); ctx.fill(); ctx.globalAlpha=1;
  ctx.fillStyle="#cfe0ff"; ctx.font="14px system-ui";
  ctx.fillText(`${currentLevel ? currentLevel.name : "—"} — Modo: ${opts.mode} — Som: ${audio.enabled?'ON':'OFF'} — Zoom: ${cam.scale.toFixed(2)}×`, 20, 32);
  ctx.fillStyle="#9ab0d6";
  ctx.fillText("Vel: " + speed.toFixed(1) + " px/s", 20, 54);
  ctx.fillText("Ângulo: " + upright.toFixed(1) + "°", 20, 74);
  ctx.fillText("Comb.: " + (ship.fuel|0), 20, 94);
  ctx.fillText("Meteors: " + meteorites.length, 160, 94);
  if(currentLevel){
    ctx.fillStyle="#73f3b1"; ctx.fillText("Lim. base Vel: " + currentLevel.baseSpeed + " px/s", 240, 54);
    ctx.fillStyle="#73f3b1"; ctx.fillText("Lim. base Âng: " + currentLevel.baseAngle + "°", 240, 74);
  }
  drawMiniMap();
}
function drawMiniMap(){
  const mw=Math.min(W-24, 280), mh=40, x= W - mw - 12, y=12;
  ctx.globalAlpha=0.85; ctx.fillStyle="rgba(6,9,19,0.55)"; roundRect(x,y,mw,mh,8); ctx.fill(); ctx.globalAlpha=1;
  ctx.fillStyle="#2a3248"; roundRect(x+8,y+mh/2-3,mw-16,6,3); ctx.fill();
  for(const p of pads){ const px = x+8 + (p.x/worldW)*(mw-16); ctx.fillStyle=p.color; ctx.fillRect(px-2, y+mh/2-6, 4, 12); }
  const sx = x+8 + (ship.x/worldW)*(mw-16); ctx.fillStyle="#bcd3ff"; ctx.beginPath(); ctx.arc(sx, y+mh/2, 4, 0, TAU); ctx.fill();
}

/* ===== Menus ===== */
let menuButtons=[], levelButtons=[];
function drawMenu(){
  drawSpaceBg(); drawMenuTitle();
  const btnW=Math.min(460, W*0.85), btnH=46, gap=12, cx=W/2-btnW/2; let cy=H/2-160; menuButtons=[];
  addButton(cx,cy,btnW,btnH,"▶ Novo Jogo",()=>startGame(0)); cy+=btnH+gap;
  const best=bestLevel(); if (best>0){ addButton(cx,cy,btnW,btnH,`⏩ Continuar (Nível ${best+1})`,()=>startGame(best)); cy+=btnH+gap; }
  addButton(cx,cy,btnW,btnH,`🎮 Modo: ${opts.mode} (M)`,()=>{ toggleMode(); drawMenu(); }); cy+=btnH+gap;
  addButton(cx,cy,btnW,btnH,"📜 Selecionar Nível",()=>{ state=STATES.LEVELSEL; render(); }); cy+=btnH+gap;
  addButton(cx,cy,btnW,btnH,"🔊 Som: ON/OFF (S)", ()=>toggleSound()); cy+=btnH+gap;
  addButton(cx,cy,btnW,btnH,"🧹 Limpar Progresso", ()=>{ localStorage.removeItem(SAVE_KEY); render(); });
  for(const b of menuButtons){ ctx.globalAlpha=0.9; ctx.fillStyle="rgba(6,9,19,0.55)"; roundRect(b.x,b.y,b.w,b.h,10); ctx.fill();
    ctx.globalAlpha=1; ctx.strokeStyle="rgba(255,255,255,0.2)"; ctx.lineWidth=1.5; roundRect(b.x,b.y,b.w,b.h,10); ctx.stroke();
    ctx.fillStyle="#cfe0ff"; ctx.font="16px system-ui"; ctx.textAlign="center"; ctx.textBaseline="middle"; ctx.fillText(b.label, b.x+b.w/2, b.y+b.h/2);
  }
  ctx.fillStyle="#9ab0d6"; ctx.font="14px system-ui"; ctx.textAlign="center";
  ctx.fillText("Teclas: ←/→ rodar, ↑ motor, P pausa, R reinicia, S som, M modo — Toque suportado 👍", W/2, H-30);
}
function drawMenuTitle(){
  ctx.fillStyle="#e7f0ff"; ctx.textAlign="center"; ctx.font="bold 42px system-ui"; ctx.fillText("MOON LANDER", W/2, 110);
  ctx.font="18px system-ui"; ctx.fillStyle="#9ab0d6";
  ctx.fillText("Zoom automático, terreno amplo e vários locais de aterragem", W/2, 138);
}
function drawLevelSelect(){
  drawSpaceBg();
  ctx.fillStyle="#e7f0ff"; ctx.textAlign="center"; ctx.font="bold 32px system-ui"; ctx.fillText("Selecionar Nível", W/2, 100);
  const cols = Math.max(3, Math.min(6, Math.floor(W/120)));
  const cellW = Math.min(140, (W-80)/cols), cellH=50, gap=12;
  const rows = Math.ceil(LEVELS_TOTAL/cols);
  const totalH = rows*cellH + (rows-1)*gap;
  let x0 = (W - (cols*cellW + (cols-1)*gap))/2;
  let y0 = 140 + Math.max(0,(H-200-totalH)/2);
  const best = bestLevel();
  let n=0;
  levelButtons.length=0;
  for(let r=0;r<rows;r++){
    for(let c=0;c<cols;c++){
      n++;
      if (n>LEVELS_TOTAL) break;
      const x = x0 + c*(cellW+gap), y = y0 + r*(cellH+gap);
      const unlocked = (n-1) <= best;
      levelButtons.push({x,y,w:cellW,h:cellH, idx:n-1, unlocked});
      ctx.globalAlpha=0.9; ctx.fillStyle= unlocked ? "rgba(6,9,19,0.6)" : "rgba(6,9,19,0.35)";
      roundRect(x,y,cellW,cellH,10); ctx.fill();
      ctx.globalAlpha=1; ctx.strokeStyle="rgba(255,255,255,0.25)"; ctx.lineWidth=1.5; roundRect(x,y,cellW,cellH,10); ctx.stroke();
      ctx.fillStyle= unlocked ? "#cfe0ff" : "#7f8cab"; ctx.font="16px system-ui"; ctx.textAlign="center"; ctx.textBaseline="middle";
      ctx.fillText(`Nível ${n}`, x+cellW/2, y+cellH/2);
    }
  }
  ctx.fillStyle="#9ab0d6"; ctx.font="14px system-ui"; ctx.textAlign="center";
  ctx.fillText("Clique/toque num nível desbloqueado • Esc/Voltar para o menu", W/2, H-30);
}
function addButton(x,y,w,h,label,action){ menuButtons.push({x,y,w,h,label,action}); }
canvas.onclick=(e)=>{
  const rect=canvas.getBoundingClientRect(); const x=e.clientX-rect.left, y=e.clientY-rect.top;
  if (state===STATES.MENU){
    for(const b of menuButtons){ if(x>=b.x && x<=b.x+b.w && y>=b.y && y<=b.y+b.h){ b.action(); return; } }
    startFromMenuDefault();
  } else if (state===STATES.LEVELSEL){
    for(const b of levelButtons){
      if(x>=b.x && x<=b.x+b.w && y>=b.y && y<=b.y+b.h && b.unlocked){ startGame(b.idx); return; }
    }
    state=STATES.MENU; render();
  } else if (state===STATES.LAND){
    nextLevel();
  }
};
addEventListener('keydown', (e)=>{ if (state===STATES.LEVELSEL && e.key==='Escape'){ state=STATES.MENU; render(); }});
function startFromMenuDefault(){ const best=bestLevel(); startGame(best>0?best:0); }
function nextLevel(){ cur++; if(cur>=levels.length){ state=STATES.OVER; } else { loadLevel(cur); state=STATES.PLAY; } }

/* ===== Render principal ===== */
function render(){
  if (state===STATES.MENU){ drawMenu(); return; }
  if (state===STATES.LEVELSEL){ drawLevelSelect(); return; }

  // fundo sem câmara
  drawSpaceBg();

  // mundo com câmara (zoom + pan)
  cam.apply();
  drawTerrain();
  drawMeteoritesCam();
  drawShip();
  drawParticles();
  cam.restore();

  // HUD fixo
  drawHUD();
  drawTouchButtons();
  drawPadOverlay();
}

/* ===== Start ===== */
state=STATES.MENU;
drawMenu();

})(); // IIFE
</script>

<script>
// PWA
if ('serviceWorker' in navigator) {
  window.addEventListener('load', () => { navigator.serviceWorker.register('./service-worker.js').catch(()=>{}); });
}
</script>
</body>
</html>
